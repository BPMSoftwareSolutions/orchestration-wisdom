<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    line-height: 1.6;
    color: #24292e;
    background-color: #fafafa;
    padding: 20px;
}

.markdown-body {
    max-width: 980px;
    margin: 0 auto;
}

h1, h2, h3, h4, h5, h6 {
    margin-top: 24px;
    margin-bottom: 16px;
    font-weight: 600;
    line-height: 1.25;
}

h1 { font-size: 2em; border-bottom: 3px solid #673ab7; padding-bottom: 10px; }
h2 { font-size: 1.5em; border-bottom: 2px solid #9575cd; padding-bottom: 8px; }
h3 { font-size: 1.25em; color: #673ab7; }
h4 { font-size: 1em; color: #9575cd; }

p { margin-bottom: 16px; }

a { color: #673ab7; text-decoration: none; }
a:hover { text-decoration: underline; }

code {
    background-color: #f6f8fa;
    border-radius: 3px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 85%;
    margin: 0;
    padding: 0.2em 0.4em;
    color: #e01e5a;
}

pre {
    background-color: #2d2d2d;
    border-radius: 6px;
    color: #f8f8f2;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 85%;
    line-height: 1.45;
    overflow: auto;
    padding: 16px;
    margin-bottom: 16px;
}

pre code {
    background-color: transparent;
    border: 0;
    color: #f8f8f2;
    display: inline;
    line-height: inherit;
    margin: 0;
    overflow: visible;
    padding: 0;
    word-wrap: normal;
}

blockquote {
    border-left: 4px solid #673ab7;
    color: #6a737d;
    padding: 0 15px;
    margin: 16px 0;
    background-color: #f6f8fa;
    border-radius: 4px;
    padding: 12px 15px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
    width: 100%;
    margin-bottom: 16px;
    overflow: auto;
}

table th {
    background-color: #673ab7;
    color: white;
    font-weight: 600;
    padding: 12px;
    text-align: left;
}

table td {
    border: 1px solid #dfe2e5;
    padding: 8px 12px;
}

table tr:nth-child(even) {
    background-color: #f6f8fa;
}

ul, ol {
    margin-bottom: 16px;
    padding-left: 2em;
}

li { margin-bottom: 4px; }

hr {
    background-color: #e1e4e8;
    border: 0;
    height: 2px;
    margin: 24px 0;
}

img {
    max-width: 100%;
    box-sizing: content-box;
}

strong { font-weight: 600; }

em { font-style: italic; }

/* Mermaid diagram styling */
.mermaid {
    background-color: #ffffff;
    border-radius: 6px;
    padding: 16px;
    margin: 16px 0;
    text-align: center;
    border: 1px solid #e1e4e8;
}
    </style>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                useMaxWidth: true,
                wrap: true
            }
        });

        // Wait for DOM to be ready
        window.addEventListener('DOMContentLoaded', async () => {
            // Find all mermaid diagrams
            const diagrams = document.querySelectorAll('.mermaid');

            for (let i = 0; i < diagrams.length; i++) {
                const diagram = diagrams[i];
                const src = diagram.textContent;

                // Render the diagram
                const { svg, bindFunctions } = await mermaid.render(`m${i}`, src);
                diagram.innerHTML = svg;
                bindFunctions?.(diagram);

                // Apply enhanced styling if it's a sequence diagram
                if (src.includes('sequenceDiagram')) {
                    enhanceSequenceDiagram(diagram);
                }
            }
        });

        function enhanceSequenceDiagram(host) {
            const svgEl = host.querySelector('svg');
            if (!svgEl) return;

            const svgns = 'http://www.w3.org/2000/svg';

            // Helper functions
            function findGroupForTextNode(textNode) {
                let el = textNode;
                while (el && el.tagName?.toLowerCase() !== 'g') el = el.parentNode;
                return el;
            }

            function pickLargestRect(group) {
                const rects = Array.from(group.querySelectorAll('rect'));
                if (!rects.length) return null;

                let best = rects[0];
                let bestArea = 0;
                for (const r of rects) {
                    const w = parseFloat(r.getAttribute('width') || '0');
                    const h = parseFloat(r.getAttribute('height') || '0');
                    const area = w * h;
                    if (area > bestArea) {
                        bestArea = area;
                        best = r;
                    }
                }
                return best;
            }

            function ensureDefs() {
                let defs = svgEl.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS(svgns, 'defs');
                    svgEl.insertBefore(defs, svgEl.firstChild);
                }
                return defs;
            }

            function hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }

            function generateColorTheme(label) {
                const hash = hashString(label);
                const hue = hash % 360;
                const saturation = 60 + (hash % 20);
                const lightness1 = 95;
                const lightness2 = 75;

                const top = `hsl(${hue}, ${saturation}%, ${lightness1}%)`;
                const bottom = `hsl(${hue}, ${saturation}%, ${lightness2}%)`;
                const stroke = `hsl(${hue}, ${saturation}%, 35%)`;

                return { top, bottom, stroke };
            }

            function rgbToGradient(rgbString) {
                const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (!match) return null;

                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);

                const darkerR = Math.max(0, r - 20);
                const darkerG = Math.max(0, g - 20);
                const darkerB = Math.max(0, b - 20);

                return {
                    top: `rgb(${r}, ${g}, ${b})`,
                    bottom: `rgb(${darkerR}, ${darkerG}, ${darkerB})`
                };
            }

            // 1) Add base filters to defs
            const defs = ensureDefs();

            defs.innerHTML += `
                <!-- Bezel-ish shadow for participants -->
                <filter id="bezelShadow" x="-35%" y="-35%" width="170%" height="170%">
                    <feDropShadow dx="0" dy="3.2" stdDeviation="2.2" flood-opacity="0.35"/>
                    <feDropShadow dx="0" dy="0" stdDeviation="1.2" flood-opacity="0.22"/>
                </filter>

                <!-- Note callout styling -->
                <linearGradient id="noteGrad" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0%" stop-color="#fff7cc"/>
                    <stop offset="100%" stop-color="#fde68a"/>
                </linearGradient>

                <filter id="noteShadow" x="-35%" y="-35%" width="170%" height="170%">
                    <feDropShadow dx="0" dy="2.5" stdDeviation="2" flood-opacity="0.35"/>
                </filter>
            `;

            // 2) Style ALL participant boxes automatically
            const allText = Array.from(svgEl.querySelectorAll('text'));
            const participantGradients = {};
            const processedGroups = new Set();

            for (const t of allText) {
                const label = (t.textContent || '').trim();
                if (!label) continue;

                const g = findGroupForTextNode(t);
                if (!g || processedGroups.has(g)) continue;

                const rect = pickLargestRect(g);
                if (!rect) continue;

                // Check if this looks like a participant box (reasonable size)
                const w = parseFloat(rect.getAttribute('width') || '0');
                const h = parseFloat(rect.getAttribute('height') || '0');
                if (w < 50 || h < 30 || w > 300) continue;

                processedGroups.add(g);

                // Generate or reuse color theme for this participant label
                const gradId = `pgrad_${hashString(label)}`;
                if (!participantGradients[gradId]) {
                    const theme = generateColorTheme(label);
                    participantGradients[gradId] = theme;

                    // Add gradient to defs (only once per unique label)
                    const gradientDef = `
                        <linearGradient id="${gradId}" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="0%" stop-color="${theme.top}"/>
                            <stop offset="100%" stop-color="${theme.bottom}"/>
                        </linearGradient>
                    `;
                    defs.innerHTML += gradientDef;
                }

                const theme = participantGradients[gradId];

                // Apply gradient and bezel effect
                rect.setAttribute('fill', `url(#${gradId})`);
                rect.setAttribute('rx', '12');
                rect.setAttribute('ry', '12');
                rect.setAttribute('stroke', theme.stroke);
                rect.setAttribute('stroke-width', '4');
                rect.setAttribute('filter', 'url(#bezelShadow)');

                // Add inner inset panel
                const x = parseFloat(rect.getAttribute('x') || '0');
                const y = parseFloat(rect.getAttribute('y') || '0');

                const already = g.querySelector('rect[data-inner-bezel="1"]');
                if (!already && w > 0 && h > 0) {
                    const inner = document.createElementNS(svgns, 'rect');
                    inner.setAttribute('data-inner-bezel', '1');
                    inner.setAttribute('x', x + 4.5);
                    inner.setAttribute('y', y + 4.5);
                    inner.setAttribute('width', Math.max(0, w - 9));
                    inner.setAttribute('height', Math.max(0, h - 9));
                    inner.setAttribute('rx', '9');
                    inner.setAttribute('ry', '9');
                    inner.setAttribute('fill', 'rgba(255,255,255,0.55)');
                    inner.setAttribute('stroke', 'rgba(255,255,255,0.65)');
                    inner.setAttribute('stroke-width', '1');
                    g.insertBefore(inner, rect.nextSibling);
                }
            }

            // 3) Style ALL rect backgrounds (from rect rgb() blocks)
            const processedRects = new Set();
            svgEl.querySelectorAll('rect').forEach(r => {
                const fill = r.getAttribute('fill');
                if (!fill || !fill.startsWith('rgb(')) return;
                if (r.hasAttribute('data-inner-bezel')) return;
                if (processedRects.has(fill)) return;

                const gradient = rgbToGradient(fill);
                if (!gradient) return;

                processedRects.add(fill);

                // Create gradient for this color
                const gradId = `rectGrad_${hashString(fill)}`;
                const gradientDef = `
                    <linearGradient id="${gradId}" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stop-color="${gradient.top}"/>
                        <stop offset="100%" stop-color="${gradient.bottom}"/>
                    </linearGradient>
                `;
                defs.innerHTML += gradientDef;

                // Apply to all rects with this fill
                svgEl.querySelectorAll('rect').forEach(rect => {
                    if (rect.getAttribute('fill') === fill && !rect.hasAttribute('data-inner-bezel')) {
                        rect.setAttribute('fill', `url(#${gradId})`);
                    }
                });
            });

            // 4) Style ALL NOTE boxes
            const processedNotes = new Set();
            for (const t of allText) {
                const text = (t.textContent || '').trim();
                if (!text || processedNotes.has(text)) continue;

                // Look for text that seems like a note (contains common patterns)
                const looksLikeNote = text.includes('—') || text.includes('Note') ||
                                     text.includes('Beat') || text.includes('Movement') ||
                                     text.length > 30;

                if (!looksLikeNote) continue;

                const g = findGroupForTextNode(t);
                if (!g) continue;

                const rect = pickLargestRect(g);
                if (!rect) continue;

                // Check if this looks like a note box (wide and not too tall)
                const w = parseFloat(rect.getAttribute('width') || '0');
                const h = parseFloat(rect.getAttribute('height') || '0');
                if (w < 100 || h < 20 || h > 80) continue;

                processedNotes.add(text);

                // Apply note styling
                rect.setAttribute('fill', 'url(#noteGrad)');
                rect.setAttribute('rx', '8');
                rect.setAttribute('ry', '8');
                rect.setAttribute('stroke', '#b45309');
                rect.setAttribute('stroke-width', '2.5');
                rect.setAttribute('filter', 'url(#noteShadow)');

                // Make text bold
                t.setAttribute('font-weight', '700');
            }
        }
    </script>
</head>
<body>
    <div class="markdown-body">
        <p>Perfect — I’ll lock those two decisions into the diagrams:</p>
<ul>
<li>✅ <strong>No Draft Editing</strong> (for MVP)</li>
<li>✅ <strong>Publish is only allowed after Validation Passed</strong> (hard gate)</li>
</ul>
<p>And then I’ll proceed with the next refinement: <strong>the Draft Pattern shape diagram</strong> (data shape, not code) + updated sequence/state diagrams.</p>
<hr />
<h2 id="updated-mvp-sequence-diagram-no-editing-publish-gated-by-validation">1) Updated MVP Sequence Diagram — No Editing, Publish Gated by Validation</h2>
<pre class="mermaid">sequenceDiagram
  autonumber

  actor Creator as 🧠 Content Creator
  participant View as 🧩 Creator Workspace (View)

  participant Upload as 📥 Upload Service
  participant Parse as 🧾 Markdown Parse Service
  participant Convert as 🔁 Pattern Conversion Service
  participant Validate as ✅ Validation Service
  participant Catalog as 📚 Pattern Catalog Service
  participant Index as 🔎 Search/Index Service

  Note over Creator,Index: MVP starts AFTER markdown exists (created off-platform)

  %% Experience A: Import
  Creator->>View: Action: Import ARTICLE.md
  View->>Upload: Store markdown file
  Upload-->>View: Upload accepted (uploadRef)
  View-->>Creator: Experience: Import Confirmed (uploadRef + next action)

  %% Experience B: Convert
  Creator->>View: Action: Convert to Pattern
  View->>Parse: Extract sections + diagrams + checklist
  Parse-->>View: ParsedDoc (structure + warnings)
  View->>Convert: Map ParsedDoc → Draft Pattern
  Convert-->>View: Draft Pattern (structured fields)
  View-->>Creator: Experience: Draft Ready (preview + validate)

  %% Experience C: Validate
  Creator->>View: Action: Run Validation
  View->>Validate: Validate Draft Pattern
  Validate-->>View: Validation Report (pass/fail + issues)
  View-->>Creator: Experience: Validation Results (pass badge OR issues list)

  alt Validation Failed
    Note over Creator,View: MVP: Fixes happen off-platform → re-import updated ARTICLE.md
    Creator->>View: Action: Import updated ARTICLE.md
  else Validation Passed
    %% Experience D: Publish (hard-gated)
    Creator->>View: Action: Publish to Catalog
    View->>Catalog: Publish Draft Pattern
    Catalog-->>View: Published (patternUrl)
    View->>Index: Index for search + filters
    Index-->>View: Indexed
    View-->>Creator: Experience: ✅ Published Success (live link)
  end
</pre>
<hr />
<h2 id="updated-view-experience-state-machine-no-editing-loop-hard-gate">2) Updated View Experience State Machine — No Editing Loop, Hard Gate</h2>
<pre class="mermaid">stateDiagram-v2
  [*] --> EmptyWorkspace

  EmptyWorkspace --> ImportReady: open creator workspace
  ImportReady --> ImportConfirmed: Import ARTICLE.md

  ImportConfirmed --> DraftReady: Convert to Pattern
  DraftReady --> Validating: Run Validation

  Validating --> ValidationFailed: issues found
  Validating --> ValidationPassed: validation passed

  ValidationFailed --> ImportReady: fix off-platform + re-import

  ValidationPassed --> Publishing: Publish to Catalog
  Publishing --> PublishedSuccess: pattern live + indexed

  PublishedSuccess --> ImportReady: import next ARTICLE.md
</pre>
<hr />
<h2 id="next-refinement-draft-pattern-shape-diagram">3) Next Refinement: Draft Pattern Shape Diagram</h2>
<p>This diagram is the “contract” for what the platform expects <strong>after conversion</strong> and <strong>before validation</strong>.</p>
<pre class="mermaid">flowchart TB
  Draft[📄 Draft Pattern]

  Draft --> Identity
  Draft --> Content
  Draft --> Diagrams
  Draft --> Checklist
  Draft --> Metadata
  Draft --> Provenance

  subgraph Identity[🆔 Identity]
    Title[Title\n(required)]
    Slug[Slug\n(required)]
    Summary[Short Summary\n(optional)]
  end

  subgraph Content[🧠 Content Blocks]
    Hook[Hook Markdown\n(required)]
    Problem[Problem Detail Markdown\n(required)]
    Decision[Decision Point Markdown\n(optional)]
    Metrics[Metrics & SLAs Markdown\n(optional)]
  end

  subgraph Diagrams[📈 Diagrams]
    AsIs[As-Is Mermaid\n(required)]
    Orchestrated[Orchestrated Mermaid\n(required)]
  end

  subgraph Checklist[✅ Implementation Checklist]
    Items[Checklist Items\n(required: 1+)]
  end

  subgraph Metadata[🏷️ Catalog Metadata]
    Industries[Industries\n(optional)]
    BrokenSignals[Broken Signals\n(optional)]
    Components[Components\n(optional)]
    Tags[Tags\n(optional)]
  end

  subgraph Provenance[🧾 Provenance]
    UploadRef[Upload Ref\n(required)]
    SourceHash[Content Hash\n(optional)]
    CreatedAt[Created Timestamp\n(required)]
  end
</pre>
<h3 id="what-this-shape-diagram-lets-us-refine-next">What this shape diagram lets us refine next</h3>
<ul>
<li>Which fields are <strong>required</strong> for MVP publish (right now: Title, Slug, Hook, Problem, both diagrams, checklist)</li>
<li>Which sections your markdown template must reliably produce</li>
<li>What Validation must check (schema + diagram budgets + quality rubric), aligned to your governance rules</li>
</ul>
<hr />
<h2 id="next-refinement-options-pick-one-and-ill-generate-diagrams">Next refinement options (pick one and I’ll generate diagrams)</h2>
<ol>
<li><p><strong>Markdown → Draft Mapping Diagram</strong><br />
Show which markdown headings map to which Draft Pattern fields (super useful for template design).</p>
</li>
<li><p><strong>Validation Gate Diagram</strong><br />
Break down validation into: Schema checks, Diagram budget checks, HQO rubric checks, and “publish eligibility”.</p>
</li>
<li><p><strong>Publish/Versioning Diagram</strong><br />
MVP decision: does re-import overwrite a draft, create a new draft, or create a new version?</p>
</li>
</ol>
<p>Just tell me: <strong>“Do #1”</strong> (or #2 / #3), and I’ll produce the next diagram set.</p>
<hr />
<p>Absolutely — here are <strong>#1 (Markdown → Draft Mapping)</strong> and <strong>#2 (Validation Gate)</strong> as diagrams you can review and refine.</p>
<hr />
<h2 id="markdown-draft-pattern-mapping-diagram">#1 — Markdown → Draft Pattern Mapping Diagram</h2>
<p>This diagram makes the <strong>import contract</strong> explicit: what headings/blocks you must have in <code>ARTICLE.md</code> for the platform to convert reliably.</p>
<pre class="mermaid">flowchart LR
  MD[📝 ARTICLE.md<br/>Markdown Source] --> PARSE[🧾 Parse Markdown<br/>Headings + Blocks]
  PARSE --> MAP[🔁 Map to Draft Pattern Fields]
  MAP --> DRAFT[📄 Draft Pattern]

  subgraph MD_STRUCTURE[Expected Markdown Structure]
    H1[# Title (H1)]
    Hook[## Hook]
    Problem[## Problem / Problem Detail]
    AsIs[```mermaid<br/>As-Is Diagram<br/>```]
    Orchestrated[```mermaid<br/>Orchestrated Diagram<br/>```]
    Decision[## Decision Point (optional)]
    Metrics[## Metrics & SLAs (optional)]
    Checklist[## Implementation Checklist<br/>- item 1<br/>- item 2<br/>...]
    Meta[Frontmatter / Tags / Notes (optional)]
  end

  MD --> MD_STRUCTURE

  subgraph FIELD_MAP[Draft Pattern Field Mapping]
    F_Title[title<br/>(required)]
    F_Slug[slug<br/>(derived from title OR frontmatter)]
    F_Hook[hookMarkdown<br/>(required)]
    F_Problem[problemDetailMarkdown<br/>(required)]
    F_AsIs[asIsDiagramMermaid<br/>(required)]
    F_Orch[orchestratedDiagramMermaid<br/>(required)]
    F_Decision[decisionPointMarkdown<br/>(optional)]
    F_Metrics[metricsMarkdown<br/>(optional)]
    F_Checklist[implementationChecklist<br/>(required: 1+)]
    F_Meta[catalogMetadata<br/>(optional: industries, brokenSignals, tags)]
  end

  MAP --> FIELD_MAP
  FIELD_MAP --> DRAFT

  %% Explicit arrows from markdown parts to fields
  H1 --> F_Title
  H1 --> F_Slug
  Hook --> F_Hook
  Problem --> F_Problem
  AsIs --> F_AsIs
  Orchestrated --> F_Orch
  Decision --> F_Decision
  Metrics --> F_Metrics
  Checklist --> F_Checklist
  Meta --> F_Meta
</pre>
<h3 id="two-key-non-assumption-notes">Two key “non-assumption” notes</h3>
<ul>
<li><p>If you don’t want to assume “As-Is vs Orchestrated” labeling in markdown yet, we can instead define:</p>
<ul>
<li>“First mermaid block = as-is”</li>
<li>“Second mermaid block = orchestrated”</li>
</ul>
</li>
<li><p>Slug derivation can be MVP-simple:</p>
<ul>
<li><code>slug = kebab-case(title)</code> unless frontmatter overrides</li>
</ul>
</li>
</ul>
<hr />
<h2 id="validation-gate-diagram-publish-eligibility">#2 — Validation Gate Diagram (Publish Eligibility)</h2>
<p>This diagram makes it obvious: <strong>validation is not one thing</strong> — it’s a set of gates. Publish is only unlocked if all hard gates pass.</p>
<pre class="mermaid">flowchart TB
  Draft[📄 Draft Pattern] --> V[✅ Validation Service]

  V --> Gate1
  V --> Gate2
  V --> Gate3
  V --> Gate4

  subgraph Gate1[Gate 1: Required Fields]
    G1a[Title present]
    G1b[Slug present]
    G1c[Hook present]
    G1d[Problem detail present]
    G1e[As-Is diagram present]
    G1f[Orchestrated diagram present]
    G1g[Checklist has 1+ items]
  end

  subgraph Gate2[Gate 2: Mermaid Diagram Budgets]
    G2a[Participant budget OK]
    G2b[Step budget OK]
    G2c[Alt/branching budget OK]
    G2d[Syntax parses]
  end

  subgraph Gate3[Gate 3: Quality Rubric Threshold]
    G3a[HQO total ≥ threshold]
    G3b[No dimension below minimum]
  end

  subgraph Gate4[Gate 4: Catalog Readiness]
    G4a[Slug uniqueness OR versioning rule satisfied]
    G4b[Search metadata safe defaults applied]
    G4c[Publish eligibility = true]
  end

  Gate1 --> Decision{All hard gates pass?}
  Gate2 --> Decision
  Gate3 --> Decision
  Gate4 --> Decision

  Decision -- No --> Fail[❌ Validation Failed<br/>Return: issue list + remediation]
  Decision -- Yes --> Pass[✅ Validation Passed<br/>Unlock: Publish Action]

  Pass --> Publish[📚 Publish to Catalog]
  Fail --> Reimport[🔁 Fix off-platform + Re-import ARTICLE.md]
</pre>
<h3 id="how-to-use-this-diagram-in-ux">How to use this diagram in UX</h3>
<ul>
<li><p>Validation Results experience should display:</p>
<ul>
<li><strong>Gate status</strong> (Passed/Failed)</li>
<li><strong>Issue list</strong> grouped by gate</li>
<li>Clear instruction: “Fix off-platform → re-import”</li>
</ul>
</li>
</ul>
<hr />
<h2 id="next-refinement-quick">Next refinement (quick)</h2>
<p>If you want, I can now produce a <strong>Validation Results UX diagram</strong> that shows exactly what the View returns on failure vs pass (still one View participant, no code, pure UX experience states).</p>

    </div>
</body>
</html>