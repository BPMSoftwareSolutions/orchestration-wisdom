<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    line-height: 1.6;
    color: #24292e;
    background-color: #fafafa;
    padding: 20px;
}

.markdown-body {
    max-width: 980px;
    margin: 0 auto;
}

h1, h2, h3, h4, h5, h6 {
    margin-top: 24px;
    margin-bottom: 16px;
    font-weight: 600;
    line-height: 1.25;
}

h1 { font-size: 2em; border-bottom: 3px solid #673ab7; padding-bottom: 10px; }
h2 { font-size: 1.5em; border-bottom: 2px solid #9575cd; padding-bottom: 8px; }
h3 { font-size: 1.25em; color: #673ab7; }
h4 { font-size: 1em; color: #9575cd; }

p { margin-bottom: 16px; }

a { color: #673ab7; text-decoration: none; }
a:hover { text-decoration: underline; }

code {
    background-color: #f6f8fa;
    border-radius: 3px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 85%;
    margin: 0;
    padding: 0.2em 0.4em;
    color: #e01e5a;
}

pre {
    background-color: #2d2d2d;
    border-radius: 6px;
    color: #f8f8f2;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 85%;
    line-height: 1.45;
    overflow: auto;
    padding: 16px;
    margin-bottom: 16px;
}

pre code {
    background-color: transparent;
    border: 0;
    color: #f8f8f2;
    display: inline;
    line-height: inherit;
    margin: 0;
    overflow: visible;
    padding: 0;
    word-wrap: normal;
}

blockquote {
    border-left: 4px solid #673ab7;
    color: #6a737d;
    padding: 0 15px;
    margin: 16px 0;
    background-color: #f6f8fa;
    border-radius: 4px;
    padding: 12px 15px;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
    width: 100%;
    margin-bottom: 16px;
    overflow: auto;
}

table th {
    background-color: #673ab7;
    color: white;
    font-weight: 600;
    padding: 12px;
    text-align: left;
}

table td {
    border: 1px solid #dfe2e5;
    padding: 8px 12px;
}

table tr:nth-child(even) {
    background-color: #f6f8fa;
}

ul, ol {
    margin-bottom: 16px;
    padding-left: 2em;
}

li { margin-bottom: 4px; }

hr {
    background-color: #e1e4e8;
    border: 0;
    height: 2px;
    margin: 24px 0;
}

img {
    max-width: 100%;
    box-sizing: content-box;
}

strong { font-weight: 600; }

em { font-style: italic; }

/* Mermaid diagram styling */
.mermaid {
    background-color: #ffffff;
    border-radius: 6px;
    padding: 16px;
    margin: 16px 0;
    text-align: center;
    border: 1px solid #e1e4e8;
}
    </style>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: false,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                useMaxWidth: true,
                wrap: true
            }
        });

        // Wait for DOM to be ready
        window.addEventListener('DOMContentLoaded', async () => {
            // Find all mermaid diagrams
            const diagrams = document.querySelectorAll('.mermaid');

            for (let i = 0; i < diagrams.length; i++) {
                const diagram = diagrams[i];
                const src = diagram.textContent;

                // Render the diagram
                const { svg, bindFunctions } = await mermaid.render(`m${i}`, src);
                diagram.innerHTML = svg;
                bindFunctions?.(diagram);

                // Apply enhanced styling if it's a sequence diagram
                if (src.includes('sequenceDiagram')) {
                    enhanceSequenceDiagram(diagram);
                }
            }
        });

        function enhanceSequenceDiagram(host) {
            const svgEl = host.querySelector('svg');
            if (!svgEl) return;

            const svgns = 'http://www.w3.org/2000/svg';

            // Helper functions
            function findGroupForTextNode(textNode) {
                let el = textNode;
                while (el && el.tagName?.toLowerCase() !== 'g') el = el.parentNode;
                return el;
            }

            function pickLargestRect(group) {
                const rects = Array.from(group.querySelectorAll('rect'));
                if (!rects.length) return null;

                let best = rects[0];
                let bestArea = 0;
                for (const r of rects) {
                    const w = parseFloat(r.getAttribute('width') || '0');
                    const h = parseFloat(r.getAttribute('height') || '0');
                    const area = w * h;
                    if (area > bestArea) {
                        bestArea = area;
                        best = r;
                    }
                }
                return best;
            }

            function ensureDefs() {
                let defs = svgEl.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS(svgns, 'defs');
                    svgEl.insertBefore(defs, svgEl.firstChild);
                }
                return defs;
            }

            function hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }

            function generateColorTheme(label) {
                const hash = hashString(label);
                const hue = hash % 360;
                const saturation = 60 + (hash % 20);
                const lightness1 = 95;
                const lightness2 = 75;

                const top = `hsl(${hue}, ${saturation}%, ${lightness1}%)`;
                const bottom = `hsl(${hue}, ${saturation}%, ${lightness2}%)`;
                const stroke = `hsl(${hue}, ${saturation}%, 35%)`;

                return { top, bottom, stroke };
            }

            function rgbToGradient(rgbString) {
                const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (!match) return null;

                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);

                const darkerR = Math.max(0, r - 20);
                const darkerG = Math.max(0, g - 20);
                const darkerB = Math.max(0, b - 20);

                return {
                    top: `rgb(${r}, ${g}, ${b})`,
                    bottom: `rgb(${darkerR}, ${darkerG}, ${darkerB})`
                };
            }

            // 1) Add base filters to defs
            const defs = ensureDefs();

            defs.innerHTML += `
                <!-- Bezel-ish shadow for participants -->
                <filter id="bezelShadow" x="-35%" y="-35%" width="170%" height="170%">
                    <feDropShadow dx="0" dy="3.2" stdDeviation="2.2" flood-opacity="0.35"/>
                    <feDropShadow dx="0" dy="0" stdDeviation="1.2" flood-opacity="0.22"/>
                </filter>

                <!-- Note callout styling -->
                <linearGradient id="noteGrad" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0%" stop-color="#fff7cc"/>
                    <stop offset="100%" stop-color="#fde68a"/>
                </linearGradient>

                <filter id="noteShadow" x="-35%" y="-35%" width="170%" height="170%">
                    <feDropShadow dx="0" dy="2.5" stdDeviation="2" flood-opacity="0.35"/>
                </filter>
            `;

            // 2) Style ALL participant boxes automatically
            const allText = Array.from(svgEl.querySelectorAll('text'));
            const participantGradients = {};
            const processedGroups = new Set();

            for (const t of allText) {
                const label = (t.textContent || '').trim();
                if (!label) continue;

                const g = findGroupForTextNode(t);
                if (!g || processedGroups.has(g)) continue;

                const rect = pickLargestRect(g);
                if (!rect) continue;

                // Check if this looks like a participant box (reasonable size)
                const w = parseFloat(rect.getAttribute('width') || '0');
                const h = parseFloat(rect.getAttribute('height') || '0');
                if (w < 50 || h < 30 || w > 300) continue;

                processedGroups.add(g);

                // Generate or reuse color theme for this participant label
                const gradId = `pgrad_${hashString(label)}`;
                if (!participantGradients[gradId]) {
                    const theme = generateColorTheme(label);
                    participantGradients[gradId] = theme;

                    // Add gradient to defs (only once per unique label)
                    const gradientDef = `
                        <linearGradient id="${gradId}" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="0%" stop-color="${theme.top}"/>
                            <stop offset="100%" stop-color="${theme.bottom}"/>
                        </linearGradient>
                    `;
                    defs.innerHTML += gradientDef;
                }

                const theme = participantGradients[gradId];

                // Apply gradient and bezel effect
                rect.setAttribute('fill', `url(#${gradId})`);
                rect.setAttribute('rx', '12');
                rect.setAttribute('ry', '12');
                rect.setAttribute('stroke', theme.stroke);
                rect.setAttribute('stroke-width', '4');
                rect.setAttribute('filter', 'url(#bezelShadow)');

                // Add inner inset panel
                const x = parseFloat(rect.getAttribute('x') || '0');
                const y = parseFloat(rect.getAttribute('y') || '0');

                const already = g.querySelector('rect[data-inner-bezel="1"]');
                if (!already && w > 0 && h > 0) {
                    const inner = document.createElementNS(svgns, 'rect');
                    inner.setAttribute('data-inner-bezel', '1');
                    inner.setAttribute('x', x + 4.5);
                    inner.setAttribute('y', y + 4.5);
                    inner.setAttribute('width', Math.max(0, w - 9));
                    inner.setAttribute('height', Math.max(0, h - 9));
                    inner.setAttribute('rx', '9');
                    inner.setAttribute('ry', '9');
                    inner.setAttribute('fill', 'rgba(255,255,255,0.55)');
                    inner.setAttribute('stroke', 'rgba(255,255,255,0.65)');
                    inner.setAttribute('stroke-width', '1');
                    g.insertBefore(inner, rect.nextSibling);
                }
            }

            // 3) Style ALL rect backgrounds (from rect rgb() blocks)
            const processedRects = new Set();
            svgEl.querySelectorAll('rect').forEach(r => {
                const fill = r.getAttribute('fill');
                if (!fill || !fill.startsWith('rgb(')) return;
                if (r.hasAttribute('data-inner-bezel')) return;
                if (processedRects.has(fill)) return;

                const gradient = rgbToGradient(fill);
                if (!gradient) return;

                processedRects.add(fill);

                // Create gradient for this color
                const gradId = `rectGrad_${hashString(fill)}`;
                const gradientDef = `
                    <linearGradient id="${gradId}" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stop-color="${gradient.top}"/>
                        <stop offset="100%" stop-color="${gradient.bottom}"/>
                    </linearGradient>
                `;
                defs.innerHTML += gradientDef;

                // Apply to all rects with this fill
                svgEl.querySelectorAll('rect').forEach(rect => {
                    if (rect.getAttribute('fill') === fill && !rect.hasAttribute('data-inner-bezel')) {
                        rect.setAttribute('fill', `url(#${gradId})`);
                    }
                });
            });

            // 4) Style ALL NOTE boxes
            const processedNotes = new Set();
            for (const t of allText) {
                const text = (t.textContent || '').trim();
                if (!text || processedNotes.has(text)) continue;

                // Look for text that seems like a note (contains common patterns)
                const looksLikeNote = text.includes('—') || text.includes('Note') ||
                                     text.includes('Beat') || text.includes('Movement') ||
                                     text.length > 30;

                if (!looksLikeNote) continue;

                const g = findGroupForTextNode(t);
                if (!g) continue;

                const rect = pickLargestRect(g);
                if (!rect) continue;

                // Check if this looks like a note box (wide and not too tall)
                const w = parseFloat(rect.getAttribute('width') || '0');
                const h = parseFloat(rect.getAttribute('height') || '0');
                if (w < 100 || h < 20 || h > 80) continue;

                processedNotes.add(text);

                // Apply note styling
                rect.setAttribute('fill', 'url(#noteGrad)');
                rect.setAttribute('rx', '8');
                rect.setAttribute('ry', '8');
                rect.setAttribute('stroke', '#b45309');
                rect.setAttribute('stroke-width', '2.5');
                rect.setAttribute('filter', 'url(#noteShadow)');

                // Make text bold
                t.setAttribute('font-weight', '700');
            }
        }
    </script>
</head>
<body>
    <div class="markdown-body">
        <h1 id="company-buyer-pattern-discovery-evaluation">Company Buyer Pattern Discovery &amp; Evaluation</h1>
<blockquote>
<p><strong>Domain</strong>: orchestration-wisdom | <strong>Status</strong>: active | <strong>Auto-generated from</strong>: <a href="../../C:/source/repos/bpm/internal/orchestration-wisdom/sequences/company-buyer-discovery.json">company-buyer-discovery.json</a></p>
</blockquote>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#user-story">User Story</a></li>
<li><a href="#business-value">Business Value</a></li>
<li><a href="#governance">Governance</a></li>
<li><a href="#workflow-movements">Workflow Movements</a>
<ul>
<li><a href="#movement--homepage-discovery--initial-browse">Movement : Homepage Discovery &amp; Initial Browse</a>
<ul>
<li><a href="#beat--homepage-load">Beat : Homepage Load</a></li>
<li><a href="#beat--read-value-proposition">Beat : Read Value Proposition</a></li>
<li><a href="#beat--navigate-to-pattern-library">Beat : Navigate to Pattern Library</a></li>
</ul>
</li>
<li><a href="#movement--filter--pattern-discovery">Movement : Filter &amp; Pattern Discovery</a>
<ul>
<li><a href="#beat--filter-by-industry">Beat : Filter by Industry</a></li>
<li><a href="#beat--filter-by-broken-signal">Beat : Filter by Broken Signal</a></li>
<li><a href="#beat--sort-by-clarity-score">Beat : Sort by Clarity Score</a></li>
<li><a href="#beat--select-pattern-card">Beat : Select Pattern Card</a></li>
</ul>
</li>
<li><a href="#movement--deep-pattern-evaluation">Movement : Deep Pattern Evaluation</a>
<ul>
<li><a href="#beat--read-hook-and-problem">Beat : Read Hook and Problem</a></li>
<li><a href="#beat--analyze-as-is-diagram">Beat : Analyze As-Is Diagram</a></li>
<li><a href="#beat--analyze-orchestrated-diagram">Beat : Analyze Orchestrated Diagram</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#metadata">Metadata</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>Documents how company buyers (VP Operations, IT Directors) discover the Orchestration Wisdom platform, evaluate patterns for their operational challenges, and make purchase/implementation decisions</p>
<p><strong>Purpose</strong>: Enable efficient pattern discovery and evaluation leading to informed purchase decisions</p>
<p><strong>Trigger</strong>: Company buyer lands on orchestration-wisdom.com homepage seeking solutions to operational problems</p>
<h2 id="user-story">User Story</h2>
<p><strong>As a</strong> VP Operations at mid-market company,<br />
<strong>I want to</strong> Find proven orchestration patterns to solve recurring operational bottlenecks,<br />
<strong>So that</strong> Reduce firefighting, improve team velocity, and demonstrate ROI to executive leadership.</p>
<h3 id="user-story-diagram">User Story Diagram</h3>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 VP Operations
  participant Homepage as 🏠 Homepage
  participant Library as 📚 Pattern Library
  participant Detail as 📄 Pattern Detail
  
  Buyer->>Homepage: Google: "support ticket escalation solution"
  Homepage-->>Buyer: ✓ "Operational problems are orchestration problems"
  
  rect rgb(230, 245, 255)
  Note over Buyer,Library: Movement 1: Discovery & Filtering
  Buyer->>Library: Browse Patterns
  Buyer->>Library: Filter: Technology, Ownership
  Library-->>Buyer: ✓ 12 matching patterns
  end
  
  rect rgb(255, 245, 230)
  Note over Buyer,Detail: Movement 2: Pattern Evaluation
  Buyer->>Detail: View "Support Ticket Escalation Backlog"
  Detail-->>Buyer: ✓ As-Is diagram (shows current pain)
  Detail-->>Buyer: ✓ Orchestrated diagram (shows solution)
  Detail-->>Buyer: ✓ HQO Score: 35/40
  end
  
  rect rgb(240, 255, 240)
  Note over Buyer,Detail: Movement 3: Decision & Action
  Buyer->>Detail: Download ARTICLE.md
  Buyer->>Detail: Review implementation checklist
  Buyer-->>Buyer: ✅ Decision: Present to leadership Monday
  end
</pre>
<h2 id="business-value">Business Value</h2>
<h2 id="governance">Governance</h2>
<h3 id="policies">Policies</h3>
<ul>
<li>Homepage must load in &lt;2 seconds</li>
<li>Pattern library must support filtering by industry and broken signals</li>
<li>All patterns must display HQO score and clarity metrics</li>
<li>Pattern details must include implementation checklist and estimated impact</li>
<li>Export functionality must generate implementation-ready artifacts</li>
</ul>
<h3 id="metrics">Metrics</h3>
<ul>
<li>Homepage bounce rate</li>
<li>Pattern discovery time (homepage → relevant pattern)</li>
<li>Pattern evaluation completion rate</li>
<li>Download/export conversion rate</li>
<li>Time from first visit to purchase decision</li>
</ul>
<h2 id="workflow-movements">Workflow Movements</h2>
<h3 id="movement-homepage-discovery-initial-browse">Movement : Homepage Discovery &amp; Initial Browse</h3>
<p>Buyer lands on homepage, understands value proposition, and navigates to pattern library</p>
<p><strong>Tempo</strong>: 120 | <strong>Status</strong>: active</p>
<h4 id="user-story-1">User Story</h4>
<p><strong>As a</strong> Company Buyer,<br />
<strong>I want to</strong> Quickly understand if this platform can solve my operational problems,<br />
<strong>So that</strong> Avoid wasting time on irrelevant solutions.</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer
  participant Homepage
  Buyer->>Homepage: Visit site
  Homepage-->>Buyer: Value prop clear
  Buyer->>Homepage: Browse Patterns
  Homepage-->>Buyer: Navigate to library
</pre>
<p><strong>Beats</strong>: 3</p>
<h4 id="beat-homepage-load">Beat : Homepage Load</h4>
<ul>
<li><strong>Handler</strong>: <code>Home.razor page render</code></li>
<li><strong>Event</strong>: homepage.visited</li>
</ul>
<p><strong>User Story</strong>:</p>
<ul>
<li><strong>Persona</strong>: First-time visitor</li>
<li><strong>Goal</strong>: Understand what this platform offers</li>
<li><strong>Benefit</strong>: Decide if worth exploring further</li>
</ul>
<p><strong>User Story Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant V as Visitor
  participant H as Homepage
  V->>H: Load page
  H-->>V: Hero + patterns
</pre>
<p><strong>Visual Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 Buyer
  participant Browser as 🌐 Browser
  participant Homepage as 🏠 Home.razor
  
  Note over Buyer,Homepage: Beat 1: Homepage Load
  
  Buyer->>Browser: Click search result
  Browser->>Homepage: GET /
  Homepage->>Homepage: Render hero section
  Homepage->>Homepage: Load featured patterns
  Homepage-->>Browser: HTML + CSS
  Browser-->>Buyer: ✅ "Operational problems are orchestration problems"
</pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Hero section must be compelling and clear</li>
<li>Featured patterns should show diversity (different industries/signals)</li>
</ul>
<h4 id="beat-read-value-proposition">Beat : Read Value Proposition</h4>
<ul>
<li><strong>Handler</strong>: <code>User reading content</code></li>
<li><strong>External System</strong>: User - Visual attention ()</li>
<li><strong>Event</strong>: value.proposition.read</li>
</ul>
<p><strong>User Story</strong>:</p>
<ul>
<li><strong>Persona</strong>: Skeptical buyer</li>
<li><strong>Goal</strong>: Validate this isn't generic consulting fluff</li>
<li><strong>Benefit</strong>: Feel confident to invest time exploring</li>
</ul>
<p><strong>User Story Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant B as Buyer
  B->>B: Read hero
  B->>B: Scan featured patterns
  B-->>B: Decision: Continue
</pre>
<p><strong>Visual Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 Buyer
  
  Note over Buyer: Beat 2: Read Value Proposition
  
  Buyer->>Buyer: Read: "Operational problems are orchestration problems"
  Buyer->>Buyer: Read: "No-scroll diagrams + implementation-ready playbooks"
  Buyer->>Buyer: Scan featured pattern cards
  Buyer->>Buyer: Recognition: "Support Ticket Escalation" = our pain point
  Buyer-->>Buyer: ✅ Decision: Worth exploring
</pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Value prop must be concise (1-2 sentences)</li>
<li>Featured patterns should show real problems, not abstractions</li>
</ul>
<h4 id="beat-navigate-to-pattern-library">Beat : Navigate to Pattern Library</h4>
<ul>
<li><strong>Handler</strong>: <code>Navigation to /patterns</code></li>
<li><strong>Event</strong>: patterns.browsed</li>
</ul>
<p><strong>User Story</strong>:</p>
<ul>
<li><strong>Persona</strong>: Engaged buyer</li>
<li><strong>Goal</strong>: See full catalog of patterns</li>
<li><strong>Benefit</strong>: Find patterns specific to my industry/problem</li>
</ul>
<p><strong>User Story Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant B as Buyer
  participant Nav
  B->>Nav: Click Browse
  Nav-->>B: Library page
</pre>
<p><strong>Visual Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 Buyer
  participant Homepage as 🏠 Home.razor
  participant Library as 📚 Patterns.razor
  
  Note over Buyer,Library: Beat 3: Navigate to Pattern Library
  
  Buyer->>Homepage: Click "Browse Patterns" button
  Homepage->>Library: Navigate /patterns
  Library->>Library: Load PatternService.GetAllPatternsAsync()
  Library->>Library: Initialize filter options
  Library-->>Buyer: ✅ Pattern library with sidebar filters
</pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Pattern library should load quickly (&lt;1 second)</li>
<li>Filters should be visible and intuitive</li>
</ul>
<hr />
<h3 id="movement-filter-pattern-discovery">Movement : Filter &amp; Pattern Discovery</h3>
<p>Buyer uses filters to narrow down patterns to most relevant for their context</p>
<p><strong>Tempo</strong>: 100 | <strong>Status</strong>: active</p>
<h4 id="user-story-2">User Story</h4>
<p><strong>As a</strong> Company Buyer,<br />
<strong>I want to</strong> Quickly find patterns matching my industry and problem type,<br />
<strong>So that</strong> Avoid information overload, focus on relevant solutions.</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer
  participant Library
  Buyer->>Library: Apply filters
  Library-->>Buyer: Filtered results
  Buyer->>Library: Select pattern
  Library-->>Buyer: Navigate to detail
</pre>
<p><strong>Beats</strong>: 4</p>
<h4 id="beat-filter-by-industry">Beat : Filter by Industry</h4>
<ul>
<li><strong>Handler</strong>: <code>FilterOptions.Industries selection + ApplyFilters()</code></li>
<li><strong>Event</strong>: pattern.filtered</li>
</ul>
<p><strong>User Story</strong>:</p>
<ul>
<li><strong>Persona</strong>: Technology company buyer</li>
<li><strong>Goal</strong>: See patterns relevant to my industry</li>
<li><strong>Benefit</strong>: Examples resonate with my operational context</li>
</ul>
<p><strong>User Story Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant B as Buyer
  participant F as Filters
  B->>F: Select Technology
  F-->>B: Filtered grid
</pre>
<p><strong>Visual Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 Buyer
  participant Sidebar as 📋 Filter Sidebar
  participant PatternService as 🔧 Pattern Service
  
  Note over Buyer,PatternService: Beat 1: Filter by Industry
  
  Buyer->>Sidebar: Check "Technology"
  Sidebar->>PatternService: FilterPatternsAsync(industries: ["Technology"])
  PatternService->>PatternService: Filter patterns matching industry
  PatternService-->>Sidebar: ✓ 24 patterns
  Sidebar-->>Buyer: ✅ Updated grid with Technology patterns
</pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Filter should update instantly (no page reload)</li>
<li>Pattern count should update to show number of matches</li>
</ul>
<h4 id="beat-filter-by-broken-signal">Beat : Filter by Broken Signal</h4>
<ul>
<li><strong>Handler</strong>: <code>FilterOptions.BrokenSignals selection + ApplyFilters()</code></li>
<li><strong>Event</strong>: pattern.filtered</li>
</ul>
<p><strong>User Story</strong>:</p>
<ul>
<li><strong>Persona</strong>: Buyer with ownership clarity issues</li>
<li><strong>Goal</strong>: Find patterns addressing ownership gaps</li>
<li><strong>Benefit</strong>: Solutions directly target my team's pain point</li>
</ul>
<p><strong>User Story Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant B as Buyer
  participant F as Filters
  B->>F: Select Ownership
  F-->>B: Refined grid
</pre>
<p><strong>Visual Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 Buyer
  participant Sidebar as 📋 Filter Sidebar
  participant PatternService as 🔧 Pattern Service
  
  Note over Buyer,PatternService: Beat 2: Filter by Broken Signal
  
  Buyer->>Sidebar: Check "Ownership"
  Sidebar->>PatternService: FilterPatternsAsync(industries: ["Technology"], brokenSignals: ["Ownership"])
  PatternService->>PatternService: Refine filter
  PatternService-->>Sidebar: ✓ 12 patterns
  Sidebar-->>Buyer: ✅ Updated grid with Ownership-related patterns
</pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Multiple filters should work together (AND logic)</li>
<li>Filter badges should show active selections</li>
</ul>
<h4 id="beat-sort-by-clarity-score">Beat : Sort by Clarity Score</h4>
<ul>
<li><strong>Handler</strong>: <code>FilterOptions.SortBy selection + ApplyFilters()</code></li>
<li><strong>Event</strong>: pattern.sorted</li>
</ul>
<p><strong>User Story</strong>:</p>
<ul>
<li><strong>Persona</strong>: Quality-focused buyer</li>
<li><strong>Goal</strong>: See highest-quality patterns first</li>
<li><strong>Benefit</strong>: Don't waste time on low-quality content</li>
</ul>
<p><strong>User Story Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant B as Buyer
  participant S as Sort
  B->>S: Sort: Clarity
  S-->>B: Reordered grid
</pre>
<p><strong>Visual Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 Buyer
  participant Dropdown as 📊 Sort Dropdown
  participant PatternService as 🔧 Pattern Service
  
  Note over Buyer,PatternService: Beat 3: Sort by Clarity Score
  
  Buyer->>Dropdown: Select "Clarity Score (Highest)"
  Dropdown->>PatternService: FilterPatternsAsync(sortBy: "clarity")
  PatternService->>PatternService: Order by ClarityScore descending
  PatternService-->>Dropdown: ✓ Sorted patterns
  Dropdown-->>Buyer: ✅ Grid reordered (highest clarity first)
</pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Clarity score should be visible on pattern cards</li>
<li>Default sort should be 'Most Referenced'</li>
</ul>
<h4 id="beat-select-pattern-card">Beat : Select Pattern Card</h4>
<ul>
<li><strong>Handler</strong>: <code>Navigation to /patterns/{slug}</code></li>
<li><strong>Event</strong>: pattern.detail.viewed</li>
</ul>
<p><strong>User Story</strong>:</p>
<ul>
<li><strong>Persona</strong>: Interested buyer</li>
<li><strong>Goal</strong>: See full pattern details and diagrams</li>
<li><strong>Benefit</strong>: Evaluate if pattern solves my specific problem</li>
</ul>
<p><strong>User Story Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant B as Buyer
  participant Card
  participant Detail
  B->>Card: Click card
  Card->>Detail: Navigate
  Detail-->>B: Full pattern
</pre>
<p><strong>Visual Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 Buyer
  participant Card as 🃏 Pattern Card
  participant Detail as 📄 Pattern Detail
  
  Note over Buyer,Detail: Beat 4: Select Pattern Card
  
  Buyer->>Card: Click "Support Ticket Escalation Backlog"
  Card->>Detail: Navigate /patterns/support-ticket-escalation
  Detail->>Detail: Load pattern from PatternService
  Detail->>Detail: Render markdown with MarkdownService
  Detail->>Detail: Initialize Mermaid.js
  Detail-->>Buyer: ✅ Full pattern detail page
</pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Pattern card should be clickable (entire card, not just title)</li>
<li>Detail page should load diagrams without flicker</li>
</ul>
<hr />
<h3 id="movement-deep-pattern-evaluation">Movement : Deep Pattern Evaluation</h3>
<p>Buyer reads pattern details, analyzes diagrams, and evaluates fit for their organization</p>
<p><strong>Tempo</strong>: 80 | <strong>Status</strong>: active</p>
<h4 id="user-story-3">User Story</h4>
<p><strong>As a</strong> Company Buyer,<br />
<strong>I want to</strong> Deeply understand the pattern and validate it solves my problem,<br />
<strong>So that</strong> Make informed decision about implementation.</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer
  participant Detail
  Buyer->>Detail: Read problem
  Buyer->>Detail: Analyze diagrams
  Buyer->>Detail: Review scorecard
  Buyer-->>Buyer: Decision
</pre>
<p><strong>Beats</strong>: 3</p>
<h4 id="beat-read-hook-and-problem">Beat : Read Hook and Problem</h4>
<ul>
<li><strong>Handler</strong>: <code>User reading markdown content rendered by MarkdownService</code></li>
<li><strong>External System</strong>: User - Visual attention ()</li>
<li><strong>Event</strong>: pattern.hook.read</li>
</ul>
<p><strong>User Story</strong>:</p>
<ul>
<li><strong>Persona</strong>: Busy executive</li>
<li><strong>Goal</strong>: Quickly determine if pattern matches my situation</li>
<li><strong>Benefit</strong>: Don't waste time on irrelevant patterns</li>
</ul>
<p><strong>User Story Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant B as Buyer
  B->>B: Read hook
  B->>B: Read problem
  B-->>B: Validation
</pre>
<p><strong>Visual Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 Buyer
  
  Note over Buyer: Beat 1: Read Hook and Problem
  
  Buyer->>Buyer: Read hook: "Escalated tickets that somehow become invisible"
  Buyer->>Buyer: Emotional recognition: "This is exactly our pain!"
  Buyer->>Buyer: Read problem detail (rendered markdown)
  Buyer->>Buyer: Validate: Describes ownership gaps we experience
  Buyer-->>Buyer: ✅ Pattern is highly relevant
</pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Hook must be emotionally resonant, not generic</li>
<li>Problem section should describe systemic issue, not blame</li>
</ul>
<h4 id="beat-analyze-as-is-diagram">Beat : Analyze As-Is Diagram</h4>
<ul>
<li><strong>Handler</strong>: <code>Mermaid.js rendering &lt;pre class=&quot;mermaid&quot;&gt; blocks</code></li>
<li><strong>External System</strong>: Mermaid.js - Diagram renderer ()</li>
<li><strong>Event</strong>: diagram.analyzed</li>
</ul>
<p><strong>User Story</strong>:</p>
<ul>
<li><strong>Persona</strong>: Visual thinker</li>
<li><strong>Goal</strong>: See my current broken workflow visualized</li>
<li><strong>Benefit</strong>: Confirm pattern understands my problem</li>
</ul>
<p><strong>User Story Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant B as Buyer
  participant D as Diagram
  B->>D: View As-Is
  D-->>B: Rendered diagram
  B->>B: Analyze flow
</pre>
<p><strong>Visual Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 Buyer
  participant Browser as 🌐 Browser
  participant Mermaid as 🎨 Mermaid.js
  
  Note over Buyer,Mermaid: Beat 2: Analyze As-Is Diagram
  
  Buyer->>Browser: Scroll to As-Is diagram section
  Browser->>Mermaid: Render <pre class="mermaid">
  Mermaid->>Mermaid: Parse sequence diagram syntax
  Mermaid->>Mermaid: Draw actors: Customer, L1, L2, L3, Queue
  Mermaid->>Mermaid: Draw 12 interaction steps
  Mermaid-->>Browser: ✓ Interactive diagram
  Browser-->>Buyer: ✓ Diagram visible (no scroll needed)
  
  Buyer->>Buyer: Analyze: Ticket → L1 → L2 → stuck in queue
  Buyer->>Buyer: Identify: No clear owner, no SLA tracking
  Buyer-->>Buyer: ✅ "This is our current broken process!"
</pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Diagram must fit in viewport (no horizontal scroll)</li>
<li>Actor names should be clear and relatable</li>
</ul>
<h4 id="beat-analyze-orchestrated-diagram">Beat : Analyze Orchestrated Diagram</h4>
<ul>
<li><strong>Handler</strong>: <code>Mermaid.js rendering orchestrated diagram</code></li>
<li><strong>External System</strong>: Mermaid.js - Diagram renderer ()</li>
<li><strong>Event</strong>: diagram.analyzed</li>
</ul>
<p><strong>User Story</strong>:</p>
<ul>
<li><strong>Persona</strong>: Solution-focused buyer</li>
<li><strong>Goal</strong>: Understand the orchestration improvement</li>
<li><strong>Benefit</strong>: Visualize how my workflow could improve</li>
</ul>
<p><strong>User Story Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant B as Buyer
  participant D as Diagram
  B->>D: View Orchestrated
  D-->>B: Solution diagram
  B->>B: Understand improvement
</pre>
<p><strong>Visual Diagram</strong>:</p>
<pre class="mermaid">sequenceDiagram
  participant Buyer as 👔 Buyer
  participant Browser as 🌐 Browser
  participant Mermaid as 🎨 Mermaid.js
  
  Note over Buyer,Mermaid: Beat 3: Analyze Orchestrated Diagram
  
  Buyer->>Browser: Scroll to Orchestrated diagram section
  Browser->>Mermaid: Render orchestrated diagram
  Mermaid->>Mermaid: Parse diagram (7 actors, 16 steps)
  Mermaid->>Mermaid: Draw new elements: Smart Router, SLA Monitor
  Mermaid-->>Buyer: ✓ Improved workflow diagram
  
  Buyer->>Buyer: Analyze: Router assigns to available L2
  Buyer->>Buyer: Analyze: SLA Monitor tracks aging tickets
  Buyer->>Buyer: Compare: 6 actors → 7 actors (added Router)
  Buyer->>Buyer: Insight: "Clear ownership + capacity awareness = solution"
  Buyer-->>Buyer: ✅ "This would solve our problem!"
</pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Orchestration elements should be visually distinct</li>
<li>Improvement should be obvious from diagram alone</li>
</ul>
<hr />
<h2 id="metadata">Metadata</h2>
<ul>
<li><strong>Version</strong>:</li>
<li><strong>Author</strong>:</li>
<li><strong>Created</strong>:</li>
<li><strong>Tags</strong>:</li>
</ul>
<hr />
<p><em>This documentation was auto-generated from the canonical sequence definition.</em><br />
<em><strong>Canonical Reference</strong>: <a href="../../C:/source/repos/bpm/internal/orchestration-wisdom/sequences/company-buyer-discovery.json">company-buyer-discovery.json</a></em></p>

    </div>
</body>
</html>